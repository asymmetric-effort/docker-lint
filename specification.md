# docker-lint — Technical Specification (Go)

**Status:** Draft v1.0
**Owner:** Sam Caldwell
**Goal:** A fast, small-footprint Dockerfile linter in Go with minimum feature parity to Hadolint and a **pluggable analyzers layer** for nested scripts (e.g., ShellCheck), delivering **faster runtime**, **shorter cold start**, and **≥80% integration test coverage**.

---

## 1. Objectives & Non‑Objectives

### 1.1 Objectives

* Go-native Dockerfile linter named **docker-lint**.
* **Feature parity with Hadolint** rule set & behavior, at minimum (

    * Same or mappable Rule IDs, severities, ignore pragmas, and config behavior).
* **Pluggable “script analyzers”** for nested languages (sh/bash/pwsh/python, etc.).
* **Deterministic, fast** execution with low memory, single static binary (no cgo by default).
* **CI-ready outputs**: human-readable, JSON, **SARIF 2.1.0**.
* **Inline suppressions** and YAML config for rule tuning & plugin mapping.
* **≥80% integration test coverage** (end-to-end, multi-file, cross-platform).

### 1.2 Non‑Objectives

* Not a Docker build tool.
* No network access by default (opt-in metadata lookups permitted but discouraged).
* Not a replacement for ShellCheck; ShellCheck is an optional plugin adapter.

---

## 2. Performance, Footprint & Quality Targets

* **Cold start (single file, 50 lines):** ≤ 50 ms on x86\_64 dev laptop.
* **Throughput:** ≥ 1000 Dockerfiles/minute on 8-core host (\~16K LOC/min) with concurrency.
* **RAM:** ≤ 40 MiB peak without external analyzers; ≤ 120 MiB with ShellCheck pool.
* **Binary size:** ≤ 12 MiB stripped (pure-Go), ≤ 16 MiB with built-in WASI runtime (optional).
* **Coverage:** ≥ 80% integration tests; unit tests for rule helpers and parsing edge cases.
* **Determinism:** Same inputs produce identical outputs (ordering, messages) absent wall-clock or network.

---

## 3. High-Level Architecture

```
Dockerfile(s)
   │
   ▼
[ Parser Bridge ]  — uses moby/buildkit Dockerfile parser
   │ AST + positions
   ▼
[ Normalizer / IR ] — stages, instructions, env/arg, shells, flags
   │ DocContext + StageContext + InstrContext
   ├──────────────► [ Core Rules Engine ] (Hadolint-parity rules in Go)
   │ Findings
   └──────────────► [ Script Extractors ] → Scripts{lang, content, mapping}
                      └─► [ Analyzer Plugins ] (ShellCheck, WASI, native)
                              Findings(mapped back to Dockerfile)

Findings → [ Aggregator ] → [ Formatters: text | json | sarif ]
                       ↳ [ Exit codes / thresholds / filters ]
```

---

## 4. Modules & Packages (Go)

* `cmd/docker-lint/` – CLI entrypoint (Cobra).
* `internal/parser/` – Thin adapter over `github.com/moby/buildkit/frontend/dockerfile/parser` retaining line/column.
* `internal/ir/` – IR types & builders: `Document`, `Stage`, `Instruction`, env/arg resolution, shell state.
* `internal/engine/` – Rule registry, scheduler, execution, aggregation, config application.
* `internal/rules/` – Native rule implementations (Hadolint parity) with unit tests per rule.
* `internal/extract/` – Script extraction from `RUN` (shell/JSON), heredocs, `ONBUILD`, respect `SHELL`.
* `internal/plugins/` – Plugin API (interfaces, models), dispatcher, caching, worker pools.

    * `internal/plugins/shellcheck/` – Subprocess adapter.
    * `internal/plugins/wasm/` – WASI host for sandboxed analyzers (optional build tag `wasm`).
* `internal/config/` – YAML config parsing/validation/merging (env & CLI overrides), schema.
* `internal/formatter/` – text, JSON, SARIF emitters.
* `internal/ignore/` – Inline ignore parser & scope manager.
* `internal/cache/` – Content-hash cache for plugin results (in-memory + optional disk cache).
* `internal/x/` – shared helpers: path, fs, version, concurrency, timing, assert.
* `testdata/` – corpus of Dockerfiles, golden outputs, parity fixtures vs Hadolint.

---

## 5. Data Model (Core)

```go
// file: internal/ir/types.go
// Document is a normalized representation of a Dockerfile with semantic caches.
type Document struct {
    Filepath      string
    AST           *parser.Node
    Stages        []*Stage
    InlineIgnores map[int]map[string]struct{} // line -> set(ruleIDs)
    EscapeChar    rune                         // default '\\'
}

type Stage struct {
    Index        int
    Name         string // explicit or autogenerated "stageN"
    From         string // image@digest or image:tag or ARG reference
    Instructions []*Instruction
    Env          map[string]string // effective ENV
    Args         map[string]string // resolved ARGs with defaults
    Shell        []string          // active shell, e.g., ["/bin/sh","-c"] or ["powershell","-Command"]
}

type Instruction struct {
    Op      string        // FROM, RUN, COPY, ADD, ARG, ENV, SHELL, etc.
    Raw     *parser.Node  // original AST node (positions)
    Args    []string      // tokenized args (JSON form preserved as argv)
    Flags   map[string]string // --from, --chown, --mount, etc.
}
```

---

## 6. Rule Engine

* **Rule interface** (pure function style):

    * `ID() string`, `Severity() string`, `Apply(ctx, *Document) ([]Finding, error)`.
    * Rules operate on IR and may register **interest filters** (opcodes) for efficient traversal.
* **Finding** fields: `Rule`, `Message`, `Severity`, `File`, `Line`, `Column`, `PrimaryRange`, `SecondaryRanges`, `Suggestion?`.
* **Registration:** central registry loads built-ins; config can enable/disable or re-severity by ID/prefix.
* **Inline ignores** syntax (Hadolint-compatible):

    * `# hadolint ignore=DL3003,DL3008` (single-line) and block form using `ignore=... start/end` markers.
* **Exit codes:** nonzero if any finding ≥ configured threshold (`error|warning|info`).

---

## 7. Script Extractors & Plugin Architecture

### 7.1 Script Extraction

* Walk `RUN` instructions and heredocs; respect active `SHELL` and `# escape=…` directive.
* JSON-form RUN → treat `argv` as command; detect shell wrappers like `"bash -lc"`.
* Produce `Script{Lang, Content, File, Stage, DocStart(Line,Col), OffsetMap}` where `OffsetMap(byteOffset)` returns (line,col) in the Dockerfile for precise mapping.
* **Size/time guards:** per-script size cap (e.g., 200 KiB), per-analysis timeout (configurable).

### 7.2 Plugin API (Go)

```go
// file: internal/plugins/api.go
// Analyzer defines a script analyzer plugin.
type Analyzer interface {
    ID() string
    Version() string
    Languages() []string // e.g., ["sh","bash"], ["powershell"], ["python"]
    Analyze(ctx context.Context, s Script) ([]Finding, error)
}

type Script struct {
    Lang      string
    Content   string
    File      string
    StageName string
    DocLine   int
    DocColumn int
    OffsetMap func(byteOff int) (line, col int)
    Hash      [32]byte
}

type Finding struct {
    RuleID   string
    Message  string
    Severity string // info|warning|error
    File     string
    Line     int
    Column   int
    Plugin   string // e.g., "shellcheck"
}
```

### 7.3 Built-in Plugins

* **ShellCheck adapter** (subprocess): calls `shellcheck --format=json -` with strict sandbox (no env, cwd tmp, rlimits, seccomp when available). Maps `SC####` to findings as `shellcheck/SC####`.
* **WASI host (optional)** via build tag `wasm`: run analyzers compiled to WASI (time/mem caps).
* **Native analyzers**: small Go linters for common patterns (e.g., `pip install ... &&` quoting issues) when beneficial.

### 7.4 Caching & Concurrency

* Cache key: `sha256(script.Content) + pluginID + pluginVersion + pluginConfigHash`.
* Fixed-size worker pools per plugin; global context cancellation on SIGINT.

---

## 8. Configuration (YAML)

### 8.1 File Resolution Order

* Default: `.docker-lint.yml` (project root), then user config `~/.config/docker-lint/config.yml`, overridden by CLI flags.
* Environment variables may override specific keys: `DOCKER_LINT_*`.

### 8.2 Schema

```yaml
version: 1
rules:
  enable: ["DL*", "shellcheck/*"]        # glob/prefix
  disable: ["DL3015", "shellcheck/SC2086"]
  severity:
    DL3008: error
    shellcheck/SC2046: warning
threshold: warning                          # fail if >= threshold
ignore:
  paths: ["vendor/**", "**/third_party/**"]
  inline: true                              # honor inline pragmas
plugins:
  shellcheck:
    enabled: true
    path: /usr/bin/shellcheck               # optional; else look in PATH
    timeout: 5s
    max_script_kib: 200
  wasm:
    enabled: false
    modules: []                             # list of WASI .wasm analyzers
script_languages:
  sh: ["shellcheck"]
  bash: ["shellcheck"]
  powershell: []
  python: []
format: text                                # text|json|sarif
colors: auto                                # auto|always|never
severity_map: {}                            # legacy alias
```

### 8.3 Inline Ignore Syntax (Dockerfile)

* `# hadolint ignore=DL3008,DL3015`
* `# hadolint ignore=DL3008 start` … `# hadolint ignore=DL3008 end`
* Extensions accepted: `# docker-lint ignore=shellcheck/SC2086`

---

## 9. CLI (Cobra)

```text
Usage: docker-lint [flags] [<Dockerfile paths or directories>]

Flags:
  -c, --config string           Path to config file
      --format string           Output format: text|json|sarif (default "text")
      --severity-threshold str  info|warning|error (default from config)
      --enable stringArray      Enable rules/plugins (repeatable)
      --disable stringArray     Disable rules/plugins (repeatable)
      --no-color                Disable ANSI colors
      --max-workers int         Concurrency cap (default: GOMAXPROCS)
      --stats                   Print perf stats to stderr
      --list-rules              Print available rules (IDs, severities)
      --print-config            Emit the effective config (after merges)
      --version                 Show version and build info
```

**Exit Codes**

* `0` = no findings ≥ threshold
* `1` = findings ≥ threshold present
* `2` = CLI/config/parse error

---

## 10. Outputs

* **Text:** grep-friendly, stable format: `FILE:LINE:COLUMN: SEVERITY RULE  message`
* **JSON:** array of findings with deterministic ordering.
* **SARIF 2.1.0:** tool -> runs -> results; rules include help text and default severity. Plugin rules appear as `shellcheck/SC####`.

---

## 11. Hadolint Parity Plan

* Build a **parity map** of Hadolint rule IDs → docker-lint rule IDs (usually identical `DL####`).
* Behavior fidelity:

    * Same detection logic (with tests derived from Hadolint corpus + crafted cases).
    * Same default severities; allow overrides via config.
    * Same ignore pragmas (plus docker-lint extended forms).
* Document any intentional deviations (with rationale) and provide compatibility flags if needed.

---

## 12. Security & Sandboxing

* Default: **no network**; deny external URL fetches.
* Subprocess analyzers run with:

    * Cleared env, locked working dir, rlimits (nofile, cpu, as), timeouts.
    * Optional seccomp profile (Linux) and `no_new_privs`.
* WASI analyzers: memory/time caps; no preopens besides a temp directory.

---

## 13. Testing Strategy (≥80% Integration Coverage)

### 13.1 Test Types

* **Unit:** rule helpers, parser normalization, config loader, ignore parser.
* **Integration (primary):**

    * End-to-end runs on a **large corpus**: real-world Dockerfiles + edge cases (heredocs, JSON-form RUN, Windows \`# escape=\`\`).
    * Differential tests vs Hadolint: compare (RuleID, severity, location); message drift allowed within tolerance.
    * Plugin path tests with ShellCheck present/absent (graceful degradation).
    * Concurrency determinism tests (stable ordering under parallelism).
* **Fuzzing:** IR builder and extractor (newline, multibyte, continuations, heredocs).

### 13.2 Coverage Accounting

* Use `go test -coverpkg=./... -covermode=atomic`.
* Integration suite reports and enforces **≥80%** line coverage; gate in CI.

---

## 14. CI/CD & Tooling

* github actions to provide github build/test pipelines.
* **Go version:** 1.24+
* **Build matrix:** linux/amd64, linux/arm64, darwin/amd64, darwin/arm64, windows/amd64.
* **Static binary:** `-ldflags "-s -w"`; reproducible builds via Go module proxy lock + `-trimpath`.
* **Linters:** `golangci-lint` with `gofmt`, `go vet`, `ineffassign`, `errcheck`.
* **CI steps:**

    1. `go mod tidy && go vet ./...`
    2. unit tests + integration tests
    3. coverage check ≥ 80%
    4. build artifacts; attach SBOM (Go modules) and provenance (SLSA level 2+ optional)
* **Releases:** GitHub Releases with checksums and container image `ghcr.io/.../docker-lint:VERSION`.

---

## 15. Directory Layout

```
.
├── cmd/docker-lint/
├── internal/
│   ├── parser/
│   ├── ir/
│   ├── engine/
│   ├── rules/
│   ├── extract/
│   ├── plugins/
│   │   ├── shellcheck/
│   │   └── wasm/    (build tag: wasm)
│   ├── config/
│   ├── formatter/
│   ├── ignore/
│   ├── cache/
│   └── x/
├── testdata/
│   ├── corpus/
│   └── golden/
└── scripts/
```

---

## 16. Example: Minimal CLI & Rule Skeletons

```go
// file: cmd/docker-lint/main.go
// (c) 2025 Asymmetric Effort, LLC. scaldwell@asymmetric-effort.com
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "os"

    "github.com/moby/buildkit/frontend/dockerfile/parser"
)

// main is the CLI entry point.
/*
main parses a Dockerfile, builds the IR, runs the rule engine and plugins,
and emits findings in the user-specified format.
*/
func main() {
    if len(os.Args) < 2 {
        fmt.Fprintln(os.Stderr, "usage: docker-lint <Dockerfile>")
        os.Exit(2)
    }
    f, err := os.Open(os.Args[1])
    if err != nil { panic(err) }
    defer f.Close()

    res, err := parser.Parse(f)
    if err != nil { panic(err) }

    doc := BuildDocument(os.Args[1], res.AST) // TODO: implement in internal/ir
    reg := NewRegistry()                      // TODO: internal/engine
    reg.Register(NewRuleNoLatestTag())        // TODO: internal/rules

    findings, err := reg.Run(context.Background(), doc)
    if err != nil { panic(err) }

    _ = json.NewEncoder(os.Stdout).Encode(findings)
}
```

```go
// file: internal/rules/no_latest_tag.go
// (c) 2025 Asymmetric Effort, LLC. scaldwell@asymmetric-effort.com
package rules

// RuleNoLatestTag flags FROM image:latest or implicit tags.
/*
RuleNoLatestTag encourages reproducible builds by requiring explicit, non-latest
tags or digests in FROM instructions.
*/
```

---

## 17. Parity Coverage Matrix (initial)

* DL3001 … DL30xx — implement in descending ROI order; track status in `docs/parity.md` with: **spec**, **tests**, **edge cases**, **notes**.
* For each rule: link to golden tests and counterexamples.

---

## 18. Error Handling & Logging

* User-facing errors are concise and actionable; include filename and position when possible.
* Internal errors use wrapped `%w` with sentinel types (`ErrParse`, `ErrConfig`, `ErrPluginTimeout`).
* Logging: quiet by default; `--stats` toggles perf diagnostics to stderr.

---

## 19. Telemetry (Optional, Off by Default)

* If enabled: anonymous counters (rules triggered, runtime, versions). Opt-in only, no file paths; respect `NO_TELEMETRY=1`.

---

## 20. Licensing & Third-Party

* MIT
* Third-party notices for BuildKit parser, optional ShellCheck, and WASI runtime if included.

---

## 21. Future Work

* Language servers integration (LSP) for IDE diagnostics.
* Autofix suggestions for select rules (e.g., replace `ADD` with `COPY`).
* Rule authoring SDK + policy packs.

---

## 22. Acceptance Criteria

1. Runs on given corpus and matches Hadolint for ≥ 95% of findings (ID+location parity).
2. Meets performance & footprint targets (§2).
3. Achieves ≥80% integration coverage with CI gate.
4. Supports ShellCheck plugin with stable mapping and inline suppression.
5. Ships single static binary and SARIF output.
